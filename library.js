
// Library

// Calls modules and orchestrates dependencies between them

var clone = require("clone")
var ramda = require("ramda")
var find = ramda.find
var contains = ramda.contains


function Library() {
  this.modules = {}
  this.singletonCache = {}
  this.collectivePrototypes = {}
  this.collectiveCache = {}
}

Library.prototype.define =
  function(name, two, three) {
    if (three) {
      var func = three
      var dependencies = two
    } else {
      var func = two
      var dependencies = []
    }

    var module = {
      name: name,
      dependencies: dependencies,
      func: func
    }

    this.modules[name] = module
  }

Library.prototype.collective =
  function(object) {
    var id = Math.random().toString(36).split(".")[1]

    this.collectivePrototypes[id] = object
    return {collective: id}
  }

Library.prototype.reset =
  function(name) {
    return {reset: name}
  }

Library.prototype.using =
  function(dependencies, func) {

    // First we're going to check which of the dependencies need to have their collectives reset:

    var resets = []

    for(var i=0; i<dependencies.length; i++) {

      if (typeof dependencies[i] == "object" && dependencies[i].reset) {

        var name = dependencies[i].reset

        // If we do need to reset something, we note it and then change the dependency back to a regular name so that when we pass the dependencies to the new (reset) library it doesn't try to reset it again.

        resets.push(name)

        dependencies[i] = name

      }
    }

    this._addDependenciesToResets(resets, dependencies)


    // If anything needs to be reset, we make a new library with the resets and call using on that.

    if (resets.length) {
      var library = this.cloneAndReset(resets)
    } else {
      var library = this
    }

    // At this point we have a properly reset library, and the dependencies should just be module names and collective IDs, so we just iterate through the dependencies and build the singletons.

    return func.apply(null, library._getArguments(dependencies, func))
  }




// Resets

// There is some special work here when we want to reset a module's collective. We have to trace back through the dependency tree and find *every* module that depends on the things we're resetting.

Library.prototype._addDependenciesToResets =
  function(resets, dependencies) {

    var oneToReset = resets.length > 0

    var another = this._getAnotherToReset.bind(this, resets, dependencies)

    while (oneToReset) {
      oneToReset = find(another)(dependencies)

      if (oneToReset) {
        resets.push(oneToReset)
      }
    }
  }

Library.prototype._getAnotherToReset =
  function(resets, dependenciesToReset, dependency) {

  var alreadyReset = contains(dependency)(resets)

  if (alreadyReset) {
    return false
  } else {
    return this._dependsOn(dependency, resets)
  }
}

Library.prototype._dependsOn =
  function(target, possibleDeps) {

    isDirectMatch = contains(target)(possibleDeps)

    if (typeof target == "function") {
      return false
    } else if (isDirectMatch) {
      return true
    }

    var dependencies = this.modules[target].dependencies

    for(var i=0; i<dependencies.length; i++) {

      var foundDeep = this._dependsOn(dependencies[i], possibleDeps)

      if (foundDeep) { return true }
    }

    return false
  }



// Arguments

// When we call a module generator or use a function, we need arguments to pass to them. For now, these are either collectives, singletons generated by those generators, or commonjs modules.

Library.prototype._getArguments =
  function(dependencies, func) {

    var args = []

    for(var i=0; i<dependencies.length; i++) {

      args.push(this._getSingleton(dependencies[i]))
    }

    return args
  }

Library.prototype._getCollective =
  function(id) {
    if (id in this.collectiveCache) {
      return this.collectiveCache[id]
    }

    var collective = clone(this.collectivePrototypes[id])

    this.collectiveCache[id] = collective

    return collective
  }

Library.prototype._getSingleton =
  function (name) {

    if (typeof name == "object" && name.collective) {

      var id = name.collective

      return this._getCollective(id)

    } else if (name in this.singletonCache) {

      return this.singletonCache[name]

    } else if (typeof name != "string") {
      throw new Error("You asked for a module by the name of "+name+" but, uh... that's not really a name.")

    } else if (module = this.modules[name]) {
      return this._generateSingleton(module)

    } else if (commonJsSingleton = require(name)) {

      this.singletonCache[name] = commonJsSingleton

      return commonJsSingleton

    } else {
      throw new Error("You don't seem to have ever mentioned a "+name+" module.")
    }

  }

Library.prototype._generateSingleton =
  function(module) {
    var deps = []

    for(var i=0; i<module.dependencies.length; i++) {

      deps.push(this._getSingleton(module.dependencies[i]))
    }

    var singleton = module.func.apply(null, deps)

    this.singletonCache[module.name] = singleton

    return singleton
  }



// Resetting

// When we have figured out what all modules need to be reset, we build a new library with the cache cleared for those.

Library.prototype.cloneAndReset =
  function(resets) {
    if (resets.length < 1) {
      return this
    }

    var newLibrary = new Library()
    newLibrary.modules = this.modules
    newLibrary.collectivePrototypes = this.collectivePrototypes

    newLibrary.singletonCache = clone(this.singletonCache)
    newLibrary.collectiveCache = clone(this.singletonCache)

    resets.forEach(function(name) {
      delete newLibrary.singletonCache[name]
      delete newLibrary.collectiveCache[name]
    })

    return newLibrary
  }



var library = new Library()
library.Library = Library
module.exports = library
